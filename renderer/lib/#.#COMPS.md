# `renderer/lib/` - Your Reusable Toolkit

This is the most important directory for creating a clean, maintainable, and scalable SvelteKit application. It holds all your reusable code, which can be easily imported into any part of your app using the `$lib/` alias.

## Core Philosophy

Code in `lib/` should be well-crafted, reusable, and, where possible, generic. A component placed here should not be tied to a single page, but should be designed to be used in multiple contexts. This is the heart of a component-driven architecture.

## How to Organize Your Library

A well-organized `lib/` is a joy to work with. Group your files by their function:

-   `lib/components/`: For all your reusable Svelte components (`Button.svelte`, `Modal.svelte`).
-   `lib/actions/`: For Svelte Actionsâ€”functions that directly manipulate the DOM (`use:clickOutside`, `use:lazyLoad`).
-   `lib/stores/`: For Svelte Stores that manage shared, reactive state (`userStore.ts`, `settingsStore.ts`).
-   `lib/utils/`: For Svelte-specific utility functions that might use framework features (unlike the pure helpers in `renderer/utils/`).
-   `lib/assets/`: For images and other assets that are directly imported into your components.
-   `lib/api/`: For code related to backend communication, abstracting away the raw `tauriAPI` calls.

## Actions vs. Components

-   **Use a Component for:** Anything that has its own markup and visual representation (a button, a form, a card).
-   **Use an Action for:** Reusable *behavior* that you want to attach to an element (a tooltip that appears on hover, an element that becomes draggable).

## Example: `Draggable.svelte`

The `Draggable.svelte` component is a perfect example of a good library component:
1.  **It is generic**: It can make *any* content draggable by using a `<slot />`.
2.  **It is self-contained**: All the logic for dragging is inside the component file.
3.  **It is reusable**: You can use `<Draggable>` on any page, in any layout, without rewriting code.

## Best Practices for Excellence

1.  **Document with Props**: Use TypeScript to define the `props` (inputs) for your components. This creates self-documenting code.
    ```svelte
    <script lang="ts">
        export let title: string;
        export let priority: 'high' | 'low' = 'low'; // Optional with default
    </script>
    ```
2.  **Emit Events**: Don't let a child component modify its parent's state directly. Instead, have the child emit events, and let the parent decide what to do.
    ```typescript
    // In child component
    import { createEventDispatcher } from 'svelte';
    const dispatch = createEventDispatcher();
    dispatch('itemSelected', { id: 123 });
    ```
3.  **Use Slots for Flexibility**: Use Svelte's `<slot>` element to allow parent components to inject content into a child. This makes your components incredibly flexible and composable. 