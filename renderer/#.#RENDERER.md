# `renderer/` - The SvelteKit Frontend

This directory contains the entire user interface of your application, built with the modern and powerful SvelteKit framework. Think of it as a complete, standalone web application that lives inside your native Tauri window.

## Core Philosophy

The frontend should be "backend-agnostic." It is a pure SvelteKit application that communicates with a generic API. This API is provided by the Rust backend through a secure bridge, but the frontend doesn't need to know the detailsâ€”it just calls the functions it's been given.

This separation of concerns is a superpower: it means you could take this entire `renderer` folder and deploy it as a website with minimal changes.

## The SvelteKit Structure

-   **`routes/`**: The heart of your app's navigation. The folder structure here defines the URL paths. See `#ROUTES.md` for a deep dive.
-   **`lib/`**: Your personal library of reusable Svelte components, actions, and utilities. See `#COMPS.md` for best practices.
-   **`static/`**: Holds all static assets like fonts, images, and global CSS files. See `#STATIC.md` for details.
-   **`app.html`**: The main HTML "shell" for the entire application. You rarely need to edit this.
-   **`utils/`**: A place for miscellaneous utility functions that are specific to the frontend. See `#UTILS.md`.

## The Bridge to the Backend (`lib/api.ts`)

This is the most important file for frontend-backend communication.
-   It defines the `window.tauriAPI` object.
-   This object provides `send()` and `receive()` methods that, under the hood, use Tauri's `invoke` and `listen` functions.
-   This provides a clean, type-safe, and consistent way for your Svelte components to interact with the powerful Rust backend.

## Best Practices for Excellence

1.  **Component-First Mindset**: Break down your UI into small, reusable Svelte components. A good component does one thing and does it well.
2.  **Embrace Stores for State**: For any piece of data that needs to be shared between multiple components, use Svelte Stores. They are simple, powerful, and reactive.
3.  **Use `onMount` for Backend Calls**: When a component needs to fetch data from the Rust backend, make the API call inside the `onMount` lifecycle function.
4.  **Keep API Logic Separate**: Do not litter your `.svelte` files with complex data fetching and manipulation. Create dedicated functions (e.g., in `lib/data-access.ts`) that use `lib/api.ts` to communicate with the backend. Your components should then call these clean, high-level functions. 